# Redis 开发与运维 读书笔记

## 第2张 API的理解和使用 P60

| 数据结构 | 是否允许重复元素 | 是否有序 | 有序实现方式 | 应用场景           |
| -------- | ---------------- | -------- | ------------ | ------------------ |
| 列表     | 是               | 是       | 索引下标     | 时间轴, 消息队列等 |
| 集合     | 否               | 否       | 无           | 标签, 社交等       |
| 有序集合 | 否               | 是       | 分值         | 排行榜系统, 社交等 |


### 2.6 有序集合

* 不能有重复成员, 可排序
* 不是下标排序, 而是每个元素设置一个分数score, 作为排序依据
* 成员不能重复, 但是分数可以重复

2.6.1 命令

1. 集合内 P134

# * 添加成员 `zadd key [NX|XX] [CH] [INCR] score member [score member ...]`     O(k * log(n)), k是添加成员的个数, n是当前有序集合的成员个数

* NX: member必须不存在, 才可以设置成功, 用于添加
* XX: member必须存在, 才能设置成功, 用于更新
* CH: 返回此次操作后, 有序集合元素和分数发生变化的个数
* INCR: 对score做增加, 相当于 zincrby
* 有序集合比集合提供了排序字段, 也产生了代价, zadd时间复杂度为O(log(n))   sadd时间复杂度为O(1)
  
# * 计算成员个数 `zcard key`     O(1)
# * 计算某个成员的分数 `zscore key member`  不存在返回nil    O(1)
# * 计算成员的排名 `zrank key member`   从低到高排名     第一名是0   O(log(n)), n是当前有序集合成员个数
# * 计算成员的排名 `zrevrank key member`   从高到底排名              O(log(n)), n是当前有序集合成员个数
# * 删除成员 `zrem key member [member ...]`                       O(k * log(n)), k是删除成员的个数, n是当前有序集合的成员个数
# * 添加成员的分数 `zincrby key increment member`                 O(log(n)), n是当前有序集合成员个数

* 例子: 给tom加9分, `zincrby user:ranking 9 tom`

# * 返回指定排名范围的成员 `zrange key start stop [withscores]`   从低到高    O(k + log(n)), k是获取成员的个数, n是当前有序集合的成员个数
# * 返回指定排名范围的成员 `zrevrange key start stop [withscores]` 从高到底   O(k + log(n)), k是获取成员的个数, n是当前有序集合的成员个数

* withscores 选项: 同时返回分数值

# * 返回指定分数范围的成员 `zrangebyscore key min max [withscores] [limit offset count]`   从低到高   O(k + log(n)), k是获取成员的个数, n是当前有序集合的成员个数
# * 返回指定分数范围的成员 `zrevrangebyscore key max min [withscores] [limit offset count]` 从高到低   O(k + log(n)), k是获取成员的个数, n是当前有序集合的成员个数

* limit offset count : 限制输出的起始位置和个数
* min 和 max 支持 开区间 (小括号) ~~和闭区间 [ 中括号 ]~~,  -inf和+inf 代表无限小和无限大
  * 例子 
    * (200 +inf  => 200 ＜ x ≤ ∞      
    * (200 (300  => 200 ＜ x ＜ 300   
    * 200 300 =>  200 ≤ x ≤ 300

# * 返回指定分数范围成员个数 `zcount key min max`                O(log(n)), n是当前有序集合成员个数
# * 删除指定排名内的升序成员 `zremrangebyrank key start stop`    O(k + log(n)), k是删除成员的个数, n是当前有序集合的成员个数
# * 删除指定分数范围的成员 `zremrangebyscore key min max`        O(k + log(n)), k是删除成员的个数, n是当前有序集合的成员个数

2. 集合间的操作

# * 交集 `zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`    O(n*k)+O(m*log(m)), n成员数最小的有序集合成员个数, k是有序集合的个数, m是结果集中成员的个数

* destination: 交集计算结果保存到键
* numkeys: 需要做交集计算键的个数
* key[ key ... ]: 需要做交集计算的键
* weights weight [ weight ... ]: 每个键的权重, 在做交集计算时, 每个键中的每个member将会自己分数乘以这个权重, 每个键的权重默认是1
* aggregate sum|min|max: 计算成员交集后, 分值可以按照sum(和) , min 最小值, max 最大值做汇总, 默认是sum

```shell
127.0.0.1:6379> ZINTERSTORE user:ranking1-2 2 user:ranking user:ranking2
(integer) 1
127.0.0.1:6379> ZRANGE user:ranking1-2 0 -1 withscores
1) "ght"
2) "200"
127.0.0.1:6379> ZINTERSTORE user:ranking1-2 2 user:ranking user:ranking2 weights 1 0.5
(integer) 1
127.0.0.1:6379> ZRANGE user:ranking1-2 0 -1 withscores
1) "ght"
2) "150"
127.0.0.1:6379> ZINTERSTORE user:ranking1-2 2 user:ranking user:ranking2 weights 1 0.5 aggregate max
(integer) 1
127.0.0.1:6379> ZRANGE user:ranking1-2 0 -1 withscores
1) "ght"
2) "100"
127.0.0.1:6379> ZINTERSTORE user:ranking1-2 1 user:ranking user:ranking2 weights 1 0.5 aggregate max
(error) ERR syntax error
127.0.0.1:6379> ZINTERSTORE user:ranking1-2 3 user:ranking user:ranking2 weights 1 0.5 aggregate max
(error) ERR syntax error
```

# * 并集 `zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`  O(n)+O(m*log(m)), n是所有有序集合成员个数和, m是结果集中成员个数

```shell
127.0.0.1:6379> ZunionSTORE user:ranking1-2 2 user:ranking user:ranking2 weights 1 0.5 aggregate max
(integer) 9
127.0.0.1:6379> ZRANGE user:ranking1-2 0 -1 withscores
 1) "jw"
 2) "11.5"
 3) "wg"
 4) "12"
 5) "zrh"
 6) "15"
 7) "mx"
 8) "22"
 9) "tj"
10) "22"
11) "ld"
12) "27.5"
13) "xcr"
14) "34"
15) "whk"
16) "49.5"
17) "ght"
18) "100"
```

2.6.2 内部编码


### 2.5 集合

* 用来保存多个字符串元素, 不允许有重复元素, 并且集合中的元素是无序的, 不能通过索引下标获取元素
* 一个集合最多有2^32-1个元素(4,294,967,295). 
* Redis支持 对集合内的增删改查, 多个集合取交, 并, 差集

2.5.1 命令

1. 集合内操作  P124

# * 添加元素 `sadd key element [element ...]`   O(k)  k是元素个数
# * 删除元素 `srem key element [element ...]`   O(k)  k是元素个数
# * 计算元素个数 `scard key`                     O(1)
# * 判断元素是否在集合中 `sismember key element`    O(1)
# * 随机从集合返回指定个数元素 `srandmember key [count]`    O(count)
# * 从集合随机弹出元素 `spop key [count]` 执行后元素会被删除    O(1)
# * 获取所有元素 `smembers key`                             O(n)  n是元素总数

* smembers , lrange , hgetall 属于比较重的命令, 元素过多存在阻塞Redis的可能, 建议使用 sscan

2. 集合间操作

# * 求多个集合的交集 `sinter key [key ...]`              O(m*k) k是多个集合中元素最少的个数, m是键个数
# * 求多个集合的并集 `sunion key [key ...]`              O(k)   k是多个集合元素个数和
# * 求多个集合的差集 `sdiff key [key ...]`  集合的顺序不同, 结果不同     O(k)   k是多个集合元素个数和
# * 交集结果保存 `sinterstore destination key [key ...]`   O(m*k) k是多个集合中元素最少的个数, m是键个数
# * 交集结果保存 `sunionstore destination key [key ...]`   O(k)   k是多个集合元素个数和
# * 交集结果保存 `sdiffstore destination key [key ...]`    O(k)   k是多个集合元素个数和

* destination 处理储存到的key

2.5.2 内部编码

* intset (整数集合) : 当集合中的元素都是整数且元素个数小于 set-max-intset-entries 配置(默认 512个)时 , 减少内存的使用
* hashtable (哈希表) : 

2.5.3 使用场景

* sadd = Tagging 标签
  * 用户和标签的关系维护应该在一个事务内执行, 防止部分命令失败造成的数据不一致   Redis的事务!!
* spop / srandmember = Random item (生成随机数, 比如抽奖)
* sadd + sinter = Social Graph (社交需求)

### 2.4 列表

* 用来存储多个有序的字符串,  每个字符串就是一个元素(element), 一个列表最多 2^32-1个元素 (4,294,967,295). 
* 可以从列表的两端插入(push)和弹出(pop), 可以获取指定范围的元素列表, 获取指定索引下标的元素
* 可以当栈 和 队列 的角色
* 列表类型的特点: 
  * 第一, 列表中的元素是有序的, 通过索引下标获取某个元素或者某个范围内的元素列表
  * 第二, 列表中的元素是可以重复的

2.4.1 命令

| 操作类型 | 操作                 |
| -------- | -------------------- |
| 添加     | rpush lpush linsert  |
| 查       | lrange lindex llen   |
| 删除     | lpop rpop lrem ltrim |
| 修改     | lset                 |
| 阻塞操作 | blpop brpop          |

1. 添加操作

# * 从右边插入元素 `rpush key value [value...]`  O(k) k是元素个数
# * 从左边插入元素 `lpush key value [value...]`  O(k) k是元素个数
# * 向某个元素前或后插入元素 `linsert key before|after pivot value`   O(n) n是pivot距离列表头或尾的距离

* 找到等于pivot的元素, 在其前(before)或后(after)插入一个新的元素value
* `linsert listkey after b w`  

2. 查找

# * 从左到右获取列表所有元素 `lrange key start end`   O(s+n) s是start偏移量, n是start到end的范围

* 索引的两个特点:
  * 从左到右分别是  0  到  N-1,  从右到左分别是   -1   到  -N
  * lrange中的end 包含了自身
* `lrange listkey 0 -1`

# * 获取列表指定索引下标的元素 `lindex key index`   O(n) , n是索引的偏移量
# * 获取列表长度 `llen key`     O(1)

3. 删除

# * 从列表左侧弹出元素 `lpop key`      O(1)
# * 从列表右侧弹出元素 `rpop key`      O(1)
# * 删除指定元素 `lrem key count value`   O(n) , n是列表长度

* count的三种情况
  * count > 0 从左到右 , 删除最多count个元素
  * count < 0 从右到左 , 删错最多count绝对值个元素
  * count = 0 删除所有

# * 按照索引范围修剪列表 `ltrim key start end`    O(n) , n是要裁剪的元素总数

4. 修改

# * 修改指定索引下标的元素 `lset key index newValue`   O(n) , n是索引的偏移量

5. 阻塞操作 这个阻塞, 只是IO的阻塞, 并不会影响到Redis的运行,

# * 阻塞式弹出 左 `blpop key [key ...] timeout`    O(1)
# * 阻塞式弹出 右 `brpop key [key ...] timeout`    O(1)

* key[key ...] : 多个列表的键
* timeout : 阻塞时间(单位: 秒)
  * 列表为空: 如果timeout = 3 , 那么客户端要等到3秒后返回, 如果timeout = 0, 那么客户端会一直阻塞等下去, 直到有新的元素添加到列表中
  * 列表不为空: 客户端会立即返回
* 注意: 
  * 如果是多个键, brpop会从左至右遍历键, 一旦有一个键能弹出元素, 客户端立即返回. 也就是说, 从这些列表中弹出一个出来. 
  * 如果多个客户端对同一个键执行brpop, 那么最先执行brpop命令的客户端获取到弹出的值

2.4.2 内部编码

* ziplist(压缩列表)
  * 当列表的元素个数小于 list-max-ziplist-entries配置(默认512个), 同时列表中每个元素的值都小于list-max-ziplist-value配置时(默认64字节)
  * 减少内存的使用
* linkedlist(链表): 当列表类型无法满足ziplist的条件时
* quicklist : 以ziplist为节点的linkedlist, 结合了ziplist和linkedlist两者的优势, 为列表类型提供了一个更为优秀的内部编码实现

2.4.3 使用场景

1. 队列消息

* lpush + brpop 命令组合, 实现阻塞队列
* 生产者用lpush 插入元素
* 消费者用 brpop 抢夺元素, 谁抢到了谁干活,  保证了消费的负载均衡和高可用性

2. 文章列表

口诀:
* lpush + lpop = Stack 栈
* lpush + rpop = Queue 队列
* lpush + ltrim = Capped Collection 有限集合
* lpush + brpop = Message Queue 消息队列



### 2.3 哈希

* 键值本身又是一个键值对结构

2.3.1 命令

# * 设置值 `hset key field value [ field value ... ]` 成功返回1   O(k) k是field个数
# * 设置值, 当field不存在的时候才插入 `hsetnx key field value`     O(1)
# * 获取值 `hget key field`   如果field不存在, 返回nil            O(1) 
# * 删除field `hdel key field [ field ... ]`                      O(k) k是field个数
# * 计算field个数 `hlen key`                                      O(1)
# * 批量设置field-value  `hmset key field value [ field value ... ]`    O(k) k是field个数
# * 批量获取field-value  `hmget key field [ field ... ]`                O(k) k是field个数
# * 判断field是否存在 `hexists key field`   存在返回1               O(1)
# * 获取所有field  `hkeys key`                   O(n) n是field总数
# * 获取所有value  `hvals key`                   O(n) n是field总数
# * 获取所有的field-value  `hgetall key` 得到的是一个field 一个value 的列表, 不是一个map     O(n) n是field总数

在使用hgetall时, 如果哈希元素个数比较多, 会存在阻塞Redis的可能, 如果开发人员只需要获取部分field, 可以使用 hmget , 如果一定要获取全部 field-value , 可以使用 hscan命令, 这个命令会渐进式遍历哈希类型

# * 自增指定数字 `hincrby key field increment`                      O(1)
# * 自增指定浮点数字  `hincrbyfloat key field increment`             O(1)
# * 计算value的字符串长度 `hstrlen key field`              O(1)

2.3.2 内部编码 P(100)

* ziplist (压缩列表) : 当元素个数小于 hash-max-ziplist-entries配置(默认512个), 同时所有值都小于hash-max-ziplist-value配置(默认64字节)是
  * 更加紧凑结构实现多个元素的连续存储, 在节约内存方面比hashtable更加优秀
* hashtable (哈希表) : 当不满足ziplist条件时, hashtable的读写时间复杂度为O(1), 

2.3.3 使用场景 P(102)

存储关系型数据

哈希类型和关系型数据库的不同点:
1. 哈希类型是稀疏的, 关系型数据库是完全结构化的.  哈希的field不一定存在, 关系型数据库的字段会是null
2. 关系型数据库可以做复杂的关系查询, 而Redis模拟复杂关系查询, 开发困难和维护成本高


三种缓存用户信息的方法:

1. 原生字符串类型, 每个属性一个键  `set user:1:name tom user:1:age 23`
   * 优点: 简单直观, 每个属性都可支持更新操作
   * 缺点: 占用过多的键, 内存占用量较大, 同时用户信息内聚性比较差, 一般不会在生产环境使用
2. 序列化字符串类型: 将用户信息序列化后用一个键保存
   * 优点: 简化变成, 如果合理的使用序列化可以提高内存的使用效率
   * 缺点: 序列化和反序列化有一定的开销, 用时每次更新属性都需要吧全部数据取出进行反序列化, 更新后在序列化到Reids中
3. 哈希类型: 每个用户属性使用一对 field-value,  但是只用一个键保存  `hmset user:1 name tom age 23 city beijing`
   * 优点: 简单直观, 如果使用合理可以减少内存空间的使用
   * 缺点: 要控制哈希在ziplist和hashtable两种内部编码的转换, hashtable会消耗更多内存




### 2.2 字符串

* 最基础的数据结构
* 字符串类型的值可以是: 字符串, 数字, 二进制, 但值最大不能超过512MB

2.2.1 命令  

1. 常用命令

# * 设置值 `set key value [ex seconds] [px milliseconds] [nx|xx]`  O(1)   
# * 设置有秒级过期时间的值 `setex key seconds value`    O(1)   
# * 设置值且键必须不存在 `setnx key value`   O(1)   

* ex 为键设置秒级过期时间
* px 为键设置毫秒级过期时间
* nx 键必须不存在, 才能设置成功 用于添加   分布式锁
* xx 键必须存在, 用于更新


```shell
# set key value
set hello world
# 添加秒级过期时间
set hello world ex 10
# 只添加
set hello world nx
# 只更新
set hello world xx

# 添加秒级过期时间2
setex hello 10 world
# 添加一个键且键必须不存在
setnx hello world
```

# * 获取值 `get key`  键不存在返回`nil`   O(1)   

# * 批量设置值 `mset key value [key value ...]`    O(K), k是键的个数
# * 批量获取值 `mget key [key ...]`  键不存在返回`nil`    O(K), k是键的个数

批量操作是为了提高开发效率, Redis自身速度超群, 网络速度成为瓶颈, 批量处理有助于提高业务效率

# * 计数 `incr key`     O(1)

返回结果: 
* 值不是整数, 返回错误
* 值是整数, 返回自增后的结果
* 键不存在, 按照值为0自增, 返回结果为1

# * 自减 `decr key`         O(1)
# * 自增指定数字 `incrby key increment`      O(1)
# * 自减指定数字 `decrby key decrement`       O(1)
# * 自增浮点数 `incrbyfloat key increment`   O(1)

2. 不常用命令

# * 追加值 `append key value` 向字符串尾部追加值      O(1)
# * 字符串长度 `strlen key`  中文占用3个字节              O(1)
# * 设置并返回原值 `getset key value` 设置的同时, 返回原有的值           O(1)
# * 设置指定位置的字符 `setrange key offeset value`                O(1)
# * 获取部分字符串 `getrange key start end`  end是偏移量 从0开始       O(n) n是字符串长度 如果字符串长度短,约等于O(1)

2.2.2 内部编码

字符串类型有三种内部编码:

* int  8个字节的长整型
* embstr   小于等于39个字节的字符串
* ram    大于39个字节的字符串

2.2.3 典型使用场景

1. 缓存功能

# 开发提示
* Redis没有命名空间, 对键名没有强制要求,特殊字符除外
* 设计合理的键名, 有利于防止间冲突和项目的可维护性
* 推荐: 业务名:对象名:id:[ 属性 ] , 键名过长会浪费内存
  * 例子: wxzj:user:1:name   简化后可以是 wxzj:u:1:n 尽量简洁就好

2. 计数

真实的技术系统还需要考虑: 防作弊, 按照不同维度计数, 数据持久化到底层数据源等

3. 共享Session

一次登录, 多台服务器都可以正常访问

4. 限速

多台服务器共享 使用频率


### 2.1.3 单线程架构

* 单线程架构和I/O多路复用模型来实现高性能的内存数据库服务
* 单线程架构:
  * 命令先进入队列, 再逐个被执行, 执行顺序不确定, 但肯定不会有两条命令被同时执行
  * 为啥这么快? 
    * 纯内存访问 重要基础
    * 非阻塞I/O, 使用epoll作为I/O多路复用技术的实现, 事件处理模型将epoll中的连接,读写,关闭都转换为时间, 不在网络I/O上浪费时间
    * 避免了线程切换和竞态产生的消耗
  * 优势: 
    * 简化数据结构和算法的实现
    * 避免了线程切换和竞态长生的消耗, 锁和线程切换通常是性能杀手
  * 问题:
    * 某个命令执行过长, 将导致其他命令阻塞

### 2.1.2 数据结构和内部编码

* 5种对外的数据结构: 字符串(string), hash, list, set, zset
* 每个对外数据结构, 都对应着多个内部编码, 而一些内部编码也可能对应着多个对外数据结构
* Redis会在合适的场景选择合适的内部编码

| key | 数据结构 | 内部编码   |
| --- | -------- | ---------- |
| key | string   | raw        |
|     |          | int        |
|     |          | embstr     |
|     | hash     | hashtable  |
|     |          | ziplist    |
|     | list     | linkedlist |
|     |          | ziplist    |
|     | set      | hashtable  |
|     |          | intset     |
|     | zset     | skiplist   |
|     |          | ziplist    |

好处:  
1. 可以改进内部编码, 对外的数据结构和命令没有影响, 类似接口和实现类的关系
2. 多种内部编码实现可以在不同场景下发挥各自的优势

# * 查询内部编码 `object encoding key` 

### 2.1.1 全局命令

# * 查看所有键  `keys *`  会遍历所有键, 当保存大量键时, 线上环境禁止使用
# * 键总数 `dbsize`  不会遍历所有键
# * 检查键是否存在 `exists key` 1存在, 0不存在
# * 删除键 `del key [key ...]`  返回删除键的个数     O(k), k是键的个数
# * 键过期 `expire key seconds`  
# * 键剩余时间  `ttl key` 大于等于0:键剩余的过期时间,  -1:键没有设置过期时间,  -2:键不存在
# * 键的数据结构类型 `type key`  键不存在,返回none



## 第1章 初始Redis

### 1.7 重点回顾

1. Redis的8个特性: 速度快, 基于键值对的数据结构服务器, 功能丰富, 简单稳定, 客户端语言多, 持久化, 主从复制, 支持高可用和分布式
2. Redis不是万金油, 有些场景不适合
3. 开发运维结合以及阅读源码是用好Redis的重要方法
4. 生产环境中使用配置文件启动Redis
5. 生产环境选取稳定版本的Redis
6. Redis3.0是重要的里程碑, 发布了Redis官方的分布式实现Redis Cluster

### 1.6 Redis 重大版本 P53

* 版本号命名规则: 第二位如果奇数, 为非稳定版本; 偶数, 为稳定版本

1. Redis2.6 2012
2. 

### 1.4  用好Redis的建议

1. 切勿当做黑盒使用, 开发与运维同样重要,   要知道Redis的原理
2. 阅读源码

### 1.5 正确安装并启动Redis

1.5.1 安装Redis

1. 在Linux上安装Redis

```shell
# 安装gcc
$ sudo apt-get update
$ sudo apt-get install build-essential


$ wget http://download.redis.io/releases/redis-3.0.7.tar.gz
$ tar xzf redis-3.0.7.tar.gz
$ ln -s redis-3.0.7 redis
$ cd redis
$ make
$ make install
```


1) 下载Redis指定版本的源码压缩包到当前目录
2) 解压缩Redis源码压缩包
3) 建立一个redis目录的软连接, 指向 redis-3.0.7
   * 注意: 建立软连接的目的是为了不把Redis目录固定在指定版本上, 有利于Redis未来版本升级
4) 进入redis目录
5) 编译 (编译之前确保操作系统已经安装gcc)
6) 安装
   * 将Redis的相关运行文件放到 /usr/local/bin/ 下, 以便在任何目录下执行Redis命令

1.5.2 配置, 启动, 操作, 关闭Redis

* Redis Shell :  src 和 /usr/local/bin 目录下几个以redis开头的可执行文件

| 可执行文件       | 作用                               |
| ---------------- | ---------------------------------- |
| redis-server     | 启动redis                          |
| redis-cli        | Redis命令行客户端                  |
| redis-benchmark  | Redis基准测试工具                  |
| redis-check-aof  | Redis AOF 持久化文件检测和修复工具 |
| redis-check-dump | Redis RDB 持久化文件检测和修复工具 |
| redis-sentinel   | 启动 Redis Sentinel                |

1. 启动Redis

三种启动方法: 默认配置, 运行配置, 配置文件启动

1) 默认配置

* 使用 Redis 的默认配置来启动  redis-server 
* 关闭的时候报错, 无法关闭, 直接kill掉了

```
10232:M 15 Sep 2020 11:33:03.807 # User requested shutdown...
10232:M 15 Sep 2020 11:33:03.808 * Saving the final RDB snapshot before exiting.
10232:M 15 Sep 2020 11:33:03.809 # Failed opening the RDB file dump.rdb (in server root dir /usr/local/bin) for saving: Permission denied
10232:M 15 Sep 2020 11:33:03.809 # Error trying to save the DB, can't exit.
```

2) 运行启动

* redis-server 加上要修改配置名和值(可以是多对), 没有配置将使用默认

```
# redis-server --configKey1 configValue1 --configKey2 configValue2
$ redis-server --port 6380
```

3) 配置文件启动

将配置写到指定文件里

```
# redis-server /opt/redis/redis.conf
```

Redis有60多个配置, 详见第14章

| 配置名    | 配置说明                                |
| --------- | --------------------------------------- |
| port      | 端口                                    |
| logfile   | 日志文件                                |
| dir       | Redis工作目录(存放持久化文件和日志文件) |
| daemonize | 是否以守护进程的方式启动Redis           |

2. Redis命令行客户端

redis-cli有两种方式连接Redis服务器

* 第一种 交互式方式 : redis-cli -h{host} -p{port}
* 第二种 命令方式:  redis-cli -ip{host} -p{port} {command}
* 注意:
  * -h参数 默认连接 127.0.0.1
  * -p参数 默认端口 6379
  * redis-cli是Redis重要工具, 还提供了很多有价值的参数

3. 停止Redis服务

shutdown

* 注意:
  * Redis关闭的过程: 断开与客户端的连接, 持久化文件生成, 是一种相对优雅的关闭方式
  * 除了shutdown命令关闭以外, kill进程也可以关掉Redis, 但不要kill-9强制杀死, 不会做持久化操作, 还会造成缓冲区等资源不能优雅关闭, 极端情况会造成AOF和复制丢失数据的情况
  * shutdown 的参数 , 代表是否在关闭Redis前, 生成持久化文件
    * shutdown nosave|save

```
localhost:6379> SHUTDOWN
not connected>

# log
25:M 15 Sep 2020 18:01:24.176 # User requested shutdown...
25:M 15 Sep 2020 18:01:24.176 * Saving the final RDB snapshot before exiting.
25:M 15 Sep 2020 18:01:24.179 * DB saved on disk
25:M 15 Sep 2020 18:01:24.179 * Removing the pid file.
25:M 15 Sep 2020 18:01:24.180 # Redis is now ready to exit, bye bye...
```



### 1.3 Redis使用场景

#### 可以

1. 缓存  提高访问速度, 降低后端数据源的压力. 键过期时间设置, 灵活控制最大内存和内存溢出后的淘汰策略
2. 排行榜系统 列表和有序集合数据结构
3. 计数器引用 支持技术功能且技术性能非常好
4. 社交网络 
5. 消息队列系统 发布订阅功能和阻塞队列的功能, 满足基本功能

#### 不可以

* 数据规模的角度 不适合存储大规模数据
* 数据冷热的角度  不适合存储冷数据


完事开头难
---------------------

* 基于键值对的NoSQL数据库
* 值可以是 String 字符串, hash 哈希, list 列表, set 集合, zset 有序集合, Bitmaps 位图, HyperLogLog , GEO 地理信息定位 等多种数据结构和算法组成
* 所有数据在内存中, 读写性能惊人
* 利用快照和日志的形式保存到硬盘上
* 提供了 键过期, 发布订阅, 事务, 流水线, Lua脚本 等附加功能

### 1.2 Redis特性

1. 速度快
   * 所有数据都存在内存中
   * 用C语言实现
   * 单线程架构
   * 开发者的精雕细琢
2. 基于键值对的数据结构服务器, 值可以有多种类型
3. 丰富的功能
   * 键过期, 实现缓存
   * 发布订阅功能, 实现消息系统
   * 支持Lua脚本功能, 利用Lua创造出新的Redis命令
   * 简单的事务功能, 一定程度上保证事务特性
   * 流水线功能, 将一批命令一次性传到Redis, 减少网络开销
4. 简单稳定
   * 源码少
   * 单线程模型
   * 不依赖操作系统的类库, 自己实现了事件处理的相关功能
5. 客户端语言多
   * TCP通信协议, 
6. 持久化
   * 两种持久化方法:  RDB 和 AOF
7. 主从复制   复制功能, 分布式Redis的基础
8. 高可用和分布式
   * 2.8版本提供了 Redis Sentinel. 保证Redis节点的故障发现和故障自动转移. 
   * 3.0版本提供了 分布式实现Redis Cluster, 是Redis真正的分布式实现, 提供了高可用, 读写和容量的扩展性